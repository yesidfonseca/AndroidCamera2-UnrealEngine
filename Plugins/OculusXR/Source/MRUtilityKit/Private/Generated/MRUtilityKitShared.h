// Copyright (c) Meta Platforms, Inc. and affiliates.

// @generated by `buck2 run //arvr/projects/mixedreality/libraries/mrutilitykit:build_and_deploy unreal`

#pragma once

#include <float.h>
#include <stddef.h>
#include <stdint.h>
#include "CoreTypes.h"
#include "Math/UnrealMath.h"
#include "Math/MathFwd.h"

struct MRUKShared
{
    static MRUKShared* GetInstance() { return Instance; }

    static void LoadMRUKSharedLibrary();
    static void FreeMRUKSharedLibrary();

    struct MrukSceneAnchor;

    struct MrukRoomAnchor;

    struct MrukUuid;

    enum MrukSceneModel
    {
        MRUK_SCENE_MODEL_V2_FALLBACK_V1 = 0,
        MRUK_SCENE_MODEL_V1 = 1,
        MRUK_SCENE_MODEL_V2 = 2,
    };

    enum MrukLogLevel
    {
        MRUK_LOG_LEVEL_DEBUG = 0,
        MRUK_LOG_LEVEL_INFO = 1,
        MRUK_LOG_LEVEL_WARN = 2,
        MRUK_LOG_LEVEL_ERROR = 3,
    };

    enum MrukResult
    {
        MRUK_SUCCESS = 0,
        MRUK_ERROR_INVALID_ARGS = 1,
        MRUK_ERROR_UNKNOWN = 2,
        MRUK_ERROR_INTERNAL = 3,
        MRUK_ERROR_DISCOVERY_ONGOING = 4,
        MRUK_ERROR_INVALID_JSON = 5,
        MRUK_ERROR_NO_ROOMS_FOUND = 6,
        MRUK_ERROR_INSUFFICIENT_RESOURCES = 7,
        MRUK_ERROR_STORAGE_AT_CAPACITY = 8,
        MRUK_ERROR_INSUFFICIENT_VIEW = 9,
        MRUK_ERROR_PERMISSION_INSUFFICIENT = 10,
        MRUK_ERROR_RATE_LIMITED = 11,
        MRUK_ERROR_TOO_DARK = 12,
        MRUK_ERROR_TOO_BRIGHT = 13,
    };

    enum MrukSurfaceType
    {
        MRUK_SURFACE_TYPE_NONE = 0,
        MRUK_SURFACE_TYPE_PLANE = 1,
        MRUK_SURFACE_TYPE_VOLUME = 2,
        MRUK_SURFACE_TYPE_MESH = 4,
        MRUK_SURFACE_TYPE_ALL = 7,
    };

    enum MrukLabel
    {
        MRUK_LABEL_FLOOR = 1,
        MRUK_LABEL_CEILING = 2,
        MRUK_LABEL_WALL_FACE = 4,
        MRUK_LABEL_TABLE = 8,
        MRUK_LABEL_COUCH = 16,
        MRUK_LABEL_DOOR_FRAME = 32,
        MRUK_LABEL_WINDOW_FRAME = 64,
        MRUK_LABEL_OTHER = 128,
        MRUK_LABEL_STORAGE = 256,
        MRUK_LABEL_BED = 512,
        MRUK_LABEL_SCREEN = 1024,
        MRUK_LABEL_LAMP = 2048,
        MRUK_LABEL_PLANT = 4096,
        MRUK_LABEL_WALL_ART = 8192,
        MRUK_LABEL_SCENE_MESH = 16384,
        MRUK_LABEL_INVISIBLE_WALL_FACE = 32768,
        MRUK_LABEL_UNKNOWN = 131072,
        MRUK_LABEL_INNER_WALL_FACE = 262144,
        MRUK_LABEL_TABLETOP = 524288,
        MRUK_LABEL_SITTING_AREA = 1048576,
        MRUK_LABEL_SLEEPING_AREA = 2097152,
        MRUK_LABEL_STORAGE_TOP = 4194304,
    };

    enum MrukEnvironmentRaycastStatus
    {
        MRUK_ENVIRONMENT_RAYCAST_STATUS_HIT = 1,
        MRUK_ENVIRONMENT_RAYCAST_STATUS_NO_HIT = 2,
        MRUK_ENVIRONMENT_RAYCAST_STATUS_HIT_POINT_OCCLUDED = 3,
        MRUK_ENVIRONMENT_RAYCAST_STATUS_HIT_POINT_OUTSIDE_FOV = 4,
        MRUK_ENVIRONMENT_RAYCAST_STATUS_RAY_OCCLUDED = 5,
        MRUK_ENVIRONMENT_RAYCAST_STATUS_INVALID_ORIENTATION = 6,
        MRUK_ENVIRONMENT_RAYCAST_STATUS_MAX = 2147483647,
    };

    typedef void (*LogPrinter)(MrukLogLevel logLevel, const char* message, uint32_t length);

    typedef void (*MrukOnPreRoomAnchorAdded)(const MrukRoomAnchor* roomAnchor, void* userContext);

    typedef void (*MrukOnRoomAnchorAdded)(const MrukRoomAnchor* roomAnchor, void* userContext);

    typedef void (*MrukOnRoomAnchorUpdated)(const MrukRoomAnchor* roomAnchor, const MrukUuid* oldRoomAnchorUuid, bool significantChange, void* userContext);

    typedef void (*MrukOnRoomAnchorRemoved)(const MrukRoomAnchor* roomAnchor, void* userContext);

    typedef void (*MrukOnSceneAnchorAdded)(const MrukSceneAnchor* sceneAnchor, void* userContext);

    typedef void (*MrukOnSceneAnchorUpdated)(const MrukSceneAnchor* sceneAnchor, bool significantChange, void* userContext);

    typedef void (*MrukOnSceneAnchorRemoved)(const MrukSceneAnchor* sceneAnchor, void* userContext);

    typedef void (*MrukOnDiscoveryFinished)(MrukResult result, void* userContext);

    typedef void (*MrukOnEnvironmentRaycasterCreated)(MrukResult result, void* userContext);

    typedef struct MrukPosef (*TrackingSpacePoseGetter)(MrukPosef MrukPosef);

    typedef void (*TrackingSpacePoseSetter)(MrukPosef pose);

    struct MrukLabelFilter
    {
        uint32_t surfaceType;
        uint32_t includedLabels;
        bool includedLabelsSet;
    };

    struct MrukQuatf
    {
        float x;
        float y;
        float z;
        float w;
    };

    struct MrukPosef
    {
        FVector3f position;
        MrukQuatf rotation;
    };

    struct MrukPolygon2f
    {
        const FVector2f* points;
        uint32_t numPoints;
    };

    struct MrukMesh2f
    {
        FVector2f* vertices;
        uint32_t numVertices;
        uint32_t* indices;
        uint32_t numIndices;
    };

    struct MrukMesh3f
    {
        FVector3f* vertices;
        uint32_t numVertices;
        uint32_t* indices;
        uint32_t numIndices;
    };

    struct MrukUuid
    {
        uint8_t data[16];
    };

    struct MrukVolume
    {
        FVector3f min;
        FVector3f max;
    };

    struct MrukPlane
    {
        float x;
        float y;
        float width;
        float height;
    };

    struct MrukSceneAnchor
    {
        uint64_t space;
        MrukUuid uuid;
        MrukUuid roomUuid;
        MrukPosef pose;
        MrukVolume volume;
        MrukPlane plane;
        MrukLabel semanticLabel;
        FVector2f* planeBoundary;
        uint32_t* globalMeshIndices;
        FVector3f* globalMeshPositions;
        uint32_t planeBoundaryCount;
        uint32_t globalMeshIndicesCount;
        uint32_t globalMeshPositionsCount;
        bool hasVolume;
        bool hasPlane;
    };

    struct MrukRoomAnchor
    {
        uint64_t space;
        MrukUuid uuid;
        MrukPosef pose;
    };

    struct MrukEventListener
    {
        MrukOnPreRoomAnchorAdded onPreRoomAnchorAdded;
        MrukOnRoomAnchorAdded onRoomAnchorAdded;
        MrukOnRoomAnchorUpdated onRoomAnchorUpdated;
        MrukOnRoomAnchorRemoved onRoomAnchorRemoved;
        MrukOnSceneAnchorAdded onSceneAnchorAdded;
        MrukOnSceneAnchorUpdated onSceneAnchorUpdated;
        MrukOnSceneAnchorRemoved onSceneAnchorRemoved;
        MrukOnDiscoveryFinished onDiscoveryFinished;
        MrukOnEnvironmentRaycasterCreated onEnvironmentRaycasterCreated;
        void* userContext;
    };

    struct MrukHit
    {
        MrukUuid roomAnchorUuid;
        MrukUuid sceneAnchorUuid;
        float hitDistance;
        FVector3f hitPosition;
        FVector3f hitNormal;
    };

    struct MrukSharedRoomsData
    {
        MrukUuid groupUuid;
        MrukUuid* roomUuids;
        uint32_t numRoomUuids;
        MrukUuid alignmentRoomUuid;
        MrukPosef roomWorldPoseOnHost;
    };

    struct _MrukUuidAlignmentTest
    {
        uint8_t padding;
        MrukUuid uuid;
    };

    struct MrukEnvironmentRaycastHitPointGetInfo
    {
        FVector3f startPoint;
        FVector3f direction;
        uint32_t filterCount;
        float maxDistance;
    };

    struct MrukEnvironmentRaycastHitPoint
    {
        MrukEnvironmentRaycastStatus status;
        FVector3f point;
        MrukQuatf orientation;
        FVector3f normal;
    };


    /**
     * This allows the engine to intercept the logs from the shared library and print them using the
     * engine's logging system. Note that the log lines are NOT NULL terminated, and so you must take
     * into account the length and be careful not to read past it.
     */
    void (*SetLogPrinter)(LogPrinter printer);

    /**
     * Create the global anchor store with a external OpenXR instance and session.
     * This should only be called once on application startup.
     * Make sure to hook up the ContextOnOpenXrEvent() function as well.
     * If the context is not needed anymore it should be destroyed with ContextDestroy() to free
     * resources.
     */
    MrukResult (*AnchorStoreCreate)(uint64_t xrInstance, uint64_t xrSession, void* xrInstanceProcAddrFunc, uint64_t baseSpace, const char** availableOpenXrExtensions, uint32_t availableOpenXrExtensionsCount);
    MrukResult (*AnchorStoreCreateWithoutOpenXr)();

    /**
     * This should be called when the OpenXR instance is destroyed and it is no longer valid to attempt
     * to make any OpenXR calls. This can happen with Link when exiting play mode.
     */
    void (*AnchorStoreShutdownOpenXr)();

    /**
     * Destroy the global anchor store
     * This should only be called once on application shutdown.
     */
    void (*AnchorStoreDestroy)();

    /**
     * If the base space changes after initialization, this function should be called to update the
     * base space.
     */
    void (*AnchorStoreSetBaseSpace)(uint64_t baseSpace);

    /**
     * Start anchor discovery in the anchor store
     */
    MrukResult (*AnchorStoreStartDiscovery)(bool shouldRemoveMissingRooms, MrukSceneModel sceneModel);

    /**
     * Start anchor query from shared group uuid in the anchor store
     */
    MrukResult (*AnchorStoreStartQueryByLocalGroup)(MrukSharedRoomsData sharedRoomsData, bool shouldRemoveMissingRooms, MrukSceneModel sceneModel);

    /**
     * Load the scene from a json string
     */
    MrukResult (*AnchorStoreLoadSceneFromJson)(const char* jsonString, bool shouldRemoveMissingRooms, MrukSceneModel sceneModel);

    /**
     * Save the scene to a json string.
     * @return The serialized JSON string. This string must be freed with FreeAnchorStoreJson after use!
     */
    const char* (*AnchorStoreSaveSceneToJson)(bool includeGlobalMesh, MrukUuid* roomUuids, uint32_t numRoomUuids);

    /**
     * Free the json string returned by AnchorStoreSaveSceneToJson.
     * @param[in] jsonString The JSON string to free.
     */
    void (*AnchorStoreFreeJson)(const char* jsonString);

    /**
     * Given a prefabricated scene description, load it in the anchor store.
     */
    MrukResult (*AnchorStoreLoadSceneFromPrefab)(MrukRoomAnchor* roomAnchors, uint32_t numRoomAnchors, MrukSceneAnchor* sceneAnchors, uint32_t numSceneAnchors);

    /**
     * Clear and remove all rooms in the anchor store.
     */
    void (*AnchorStoreClearRooms)();

    /**
     * Clear and remove the room that matches the given uuid.
     */
    void (*AnchorStoreClearRoom)(MrukUuid roomUuid);

    /**
     * Allows to forward OpenXR events from the engine into the shared library
     */
    void (*AnchorStoreOnOpenXrEvent)(void* baseEventHeader);

    /**
     * Needs to be called every tick by the engine.
     */
    void (*AnchorStoreTick)(uint64_t nextPredictedDisplayTime);
    void (*AnchorStoreRegisterEventListener)(MrukEventListener listener);

    /**
     * Cast a ray against all anchors in the room and return the first hit.
     * A maxDistance of <= 0 will return the first hit regardless of distance.
     */
    bool (*AnchorStoreRaycastRoom)(MrukUuid roomUuid, FVector3f origin, FVector3f direction, float maxDistance, MrukLabelFilter labelFilter, MrukHit* outHit);

    /**
     * Cast a ray against all anchors in the room and return all hits along the ray.
     * A maxDistance of <= 0 will return the hits along the ray regardless of distance.
     */
    bool (*AnchorStoreRaycastRoomAll)(MrukUuid roomUuid, FVector3f origin, FVector3f direction, float maxDistance, MrukLabelFilter labelFilter, MrukHit* outHits, uint32_t* outHitsCount);

    /**
     * Cast a ray against the anchor in the room and return the first hit.
     * A maxDistance of <= 0 will return the hits along the ray regardless of distance.
     */
    bool (*AnchorStoreRaycastAnchor)(MrukUuid sceneAnchorUuid, FVector3f origin, FVector3f direction, float maxDistance, uint32_t surfaceTypes, MrukHit* outHit);

    /**
     * Cast a ray against the anchor in the room and return all hits along the ray.
     * A maxDistance of <= 0 will return the hits along the ray regardless of distance.
     */
    bool (*AnchorStoreRaycastAnchorAll)(MrukUuid sceneAnchorUuid, FVector3f origin, FVector3f direction, float maxDistance, uint32_t surfaceTypes, MrukHit* outHits, uint32_t* outHitsCount);
    bool (*AnchorStoreIsDiscoveryRunning)();

    /**
     * Get the world lock offset for a given room. This is the difference between the room's initial
     * pose when it was created and the current pose.
     */
    bool (*AnchorStoreGetWorldLockOffset)(MrukUuid roomUuid, MrukPosef* offset);

    /**
     * Add two vectors together. This is implemented as a test to ensure the native shared
     * library is working correctly.
     *
     * @param[in] a The first vector.
     * @param[in] b The second vector.
     * @return The sum of the two vectors.
     */
    FVector3f (*AddVectors)(FVector3f a, FVector3f b);

    /**
     * Triangulate a polygon with holes, any winding order works. The first polyline defines the main
     * polygon. Following polylines define holes. This function will allocate memory for the vertices
     * and indices. You *MUST* call FreeMesh() when you are done with it or you will leak memory.
     *
     * @param[in] polygons The polygon to triangulate.
     * @param[in] numPolygons The number of polygons in the array.
     * @return mesh The triangulated mesh.
     */
    MrukMesh2f (*TriangulatePolygon)(const MrukPolygon2f* polygons, uint32_t numPolygons);

    /**
     * Free the memory allocated by TriangulatePolygon.
     *
     * @param[in] mesh The mesh to free.
     */
    void (*FreeMesh)(MrukMesh2f* mesh);

    /**
     * Compute the mesh segmentation for a given set of vertices, indices and segmentation points.
     * You *MUST* call FreeMeshSegmentation() on the meshSegments array when you are done with it or you
     * will leak memory.
     *
     * @param[in] vertices The mesh vertices.
     * @param[in] numVertices The number of vertices in the mesh.
     * @param[in] indices The mesh indices.
     * @param[in] numIndices The number of indices in the mesh.
     * @param[in] segmentationPoints The points that should be used to calculate the segments.
     * @param[in] numSegmentationPoints The number of segmentation points.
     * @param[in] reservedMin The minimum bounding box for the reserved segment.
     * @param[in] reservedMax The maximum bounding box for the reserved segment.
     * @param[out] meshSegments The resulting segments.
     * @param[out] numSegments The number of segments in the resulting array.
     * @param[out] reservedSegment The segment that is inside the reserved bounding box.
     */
    MrukResult (*ComputeMeshSegmentation)(const FVector3f* vertices, uint32_t numVertices, const uint32_t* indices, uint32_t numIndices, const FVector3f* segmentationPoints, uint32_t numSegmentationPoints, FVector3f reservedMin, FVector3f reservedMax, MrukMesh3f** meshSegments, uint32_t* numSegments, MrukMesh3f* reservedSegment);

    /**
     * Free the memory allocated by ComputeMeshSegmentation.
     *
     * @param[in] meshSegments The array of segments to free.
     * @param[in] numSegments The number of segments in the array.
     * @param[in] reservedSegment The reserved segment to free.
     */
    void (*FreeMeshSegmentation)(const MrukMesh3f* meshSegments, uint32_t numSegments, MrukMesh3f* reservedSegment);

    /**
     * The is a test function purely to test the marshalling of Uuid from C# to C++. It ensures that the
     * packing between clang C++ and the C# definitions of MrukUuid are compatible.
     *
     * @param[in] packedUuid A uuid packed into a structure.
     * @return A copy of the uuid that was passed in the structure.
     */
    MrukUuid (*_TestUuidMarshalling)(_MrukUuidAlignmentTest packedUuid);

    /**
     * Converts the given label to the matching MrukLabel.
     *
     * @param[in] label The label as string.
     * @return The converted MrukLabel.
     */
    MrukLabel (*StringToMrukLabel)(const char* label);

    /**
     * Creates the enviornment raycaster and fires the onEnvironmentRaycasterCreated event when the
     * creation is complete.
     */
    void (*CreateEnvironmentRaycaster)();

    /**
     * Destroys the enviornment raycaster.
     */
    void (*DestroyEnvironmentRaycaster)();

    /**
     * Performs an environment raycast.
     * Ensure that the environment raycaster is created before calling this function.
     * @param[in] info The raycast info.
     * @param[out] hitPoint The hit point.
     */
    void (*PerformEnvironmentRaycast)(const MrukEnvironmentRaycastHitPointGetInfo* info, MrukEnvironmentRaycastHitPoint* hitPoint);
    void (*SetTrackingSpacePoseGetter)(TrackingSpacePoseGetter getter);
    void (*SetTrackingSpacePoseSetter)(TrackingSpacePoseSetter setter);

private:

    void LoadNativeFunctions()
    {
        SetLogPrinter = reinterpret_cast<decltype(SetLogPrinter)>(LoadFunction(TEXT("SetLogPrinter")));
        AnchorStoreCreate = reinterpret_cast<decltype(AnchorStoreCreate)>(LoadFunction(TEXT("AnchorStoreCreate")));
        AnchorStoreCreateWithoutOpenXr = reinterpret_cast<decltype(AnchorStoreCreateWithoutOpenXr)>(LoadFunction(TEXT("AnchorStoreCreateWithoutOpenXr")));
        AnchorStoreShutdownOpenXr = reinterpret_cast<decltype(AnchorStoreShutdownOpenXr)>(LoadFunction(TEXT("AnchorStoreShutdownOpenXr")));
        AnchorStoreDestroy = reinterpret_cast<decltype(AnchorStoreDestroy)>(LoadFunction(TEXT("AnchorStoreDestroy")));
        AnchorStoreSetBaseSpace = reinterpret_cast<decltype(AnchorStoreSetBaseSpace)>(LoadFunction(TEXT("AnchorStoreSetBaseSpace")));
        AnchorStoreStartDiscovery = reinterpret_cast<decltype(AnchorStoreStartDiscovery)>(LoadFunction(TEXT("AnchorStoreStartDiscovery")));
        AnchorStoreStartQueryByLocalGroup = reinterpret_cast<decltype(AnchorStoreStartQueryByLocalGroup)>(LoadFunction(TEXT("AnchorStoreStartQueryByLocalGroup")));
        AnchorStoreLoadSceneFromJson = reinterpret_cast<decltype(AnchorStoreLoadSceneFromJson)>(LoadFunction(TEXT("AnchorStoreLoadSceneFromJson")));
        AnchorStoreSaveSceneToJson = reinterpret_cast<decltype(AnchorStoreSaveSceneToJson)>(LoadFunction(TEXT("AnchorStoreSaveSceneToJson")));
        AnchorStoreFreeJson = reinterpret_cast<decltype(AnchorStoreFreeJson)>(LoadFunction(TEXT("AnchorStoreFreeJson")));
        AnchorStoreLoadSceneFromPrefab = reinterpret_cast<decltype(AnchorStoreLoadSceneFromPrefab)>(LoadFunction(TEXT("AnchorStoreLoadSceneFromPrefab")));
        AnchorStoreClearRooms = reinterpret_cast<decltype(AnchorStoreClearRooms)>(LoadFunction(TEXT("AnchorStoreClearRooms")));
        AnchorStoreClearRoom = reinterpret_cast<decltype(AnchorStoreClearRoom)>(LoadFunction(TEXT("AnchorStoreClearRoom")));
        AnchorStoreOnOpenXrEvent = reinterpret_cast<decltype(AnchorStoreOnOpenXrEvent)>(LoadFunction(TEXT("AnchorStoreOnOpenXrEvent")));
        AnchorStoreTick = reinterpret_cast<decltype(AnchorStoreTick)>(LoadFunction(TEXT("AnchorStoreTick")));
        AnchorStoreRegisterEventListener = reinterpret_cast<decltype(AnchorStoreRegisterEventListener)>(LoadFunction(TEXT("AnchorStoreRegisterEventListener")));
        AnchorStoreRaycastRoom = reinterpret_cast<decltype(AnchorStoreRaycastRoom)>(LoadFunction(TEXT("AnchorStoreRaycastRoom")));
        AnchorStoreRaycastRoomAll = reinterpret_cast<decltype(AnchorStoreRaycastRoomAll)>(LoadFunction(TEXT("AnchorStoreRaycastRoomAll")));
        AnchorStoreRaycastAnchor = reinterpret_cast<decltype(AnchorStoreRaycastAnchor)>(LoadFunction(TEXT("AnchorStoreRaycastAnchor")));
        AnchorStoreRaycastAnchorAll = reinterpret_cast<decltype(AnchorStoreRaycastAnchorAll)>(LoadFunction(TEXT("AnchorStoreRaycastAnchorAll")));
        AnchorStoreIsDiscoveryRunning = reinterpret_cast<decltype(AnchorStoreIsDiscoveryRunning)>(LoadFunction(TEXT("AnchorStoreIsDiscoveryRunning")));
        AnchorStoreGetWorldLockOffset = reinterpret_cast<decltype(AnchorStoreGetWorldLockOffset)>(LoadFunction(TEXT("AnchorStoreGetWorldLockOffset")));
        AddVectors = reinterpret_cast<decltype(AddVectors)>(LoadFunction(TEXT("AddVectors")));
        TriangulatePolygon = reinterpret_cast<decltype(TriangulatePolygon)>(LoadFunction(TEXT("TriangulatePolygon")));
        FreeMesh = reinterpret_cast<decltype(FreeMesh)>(LoadFunction(TEXT("FreeMesh")));
        ComputeMeshSegmentation = reinterpret_cast<decltype(ComputeMeshSegmentation)>(LoadFunction(TEXT("ComputeMeshSegmentation")));
        FreeMeshSegmentation = reinterpret_cast<decltype(FreeMeshSegmentation)>(LoadFunction(TEXT("FreeMeshSegmentation")));
        _TestUuidMarshalling = reinterpret_cast<decltype(_TestUuidMarshalling)>(LoadFunction(TEXT("_TestUuidMarshalling")));
        StringToMrukLabel = reinterpret_cast<decltype(StringToMrukLabel)>(LoadFunction(TEXT("StringToMrukLabel")));
        CreateEnvironmentRaycaster = reinterpret_cast<decltype(CreateEnvironmentRaycaster)>(LoadFunction(TEXT("CreateEnvironmentRaycaster")));
        DestroyEnvironmentRaycaster = reinterpret_cast<decltype(DestroyEnvironmentRaycaster)>(LoadFunction(TEXT("DestroyEnvironmentRaycaster")));
        PerformEnvironmentRaycast = reinterpret_cast<decltype(PerformEnvironmentRaycast)>(LoadFunction(TEXT("PerformEnvironmentRaycast")));
        SetTrackingSpacePoseGetter = reinterpret_cast<decltype(SetTrackingSpacePoseGetter)>(LoadFunction(TEXT("SetTrackingSpacePoseGetter")));
        SetTrackingSpacePoseSetter = reinterpret_cast<decltype(SetTrackingSpacePoseSetter)>(LoadFunction(TEXT("SetTrackingSpacePoseSetter")));
    }

    void UnloadNativeFunctions()
    {
        SetLogPrinter = nullptr;
        AnchorStoreCreate = nullptr;
        AnchorStoreCreateWithoutOpenXr = nullptr;
        AnchorStoreShutdownOpenXr = nullptr;
        AnchorStoreDestroy = nullptr;
        AnchorStoreSetBaseSpace = nullptr;
        AnchorStoreStartDiscovery = nullptr;
        AnchorStoreStartQueryByLocalGroup = nullptr;
        AnchorStoreLoadSceneFromJson = nullptr;
        AnchorStoreSaveSceneToJson = nullptr;
        AnchorStoreFreeJson = nullptr;
        AnchorStoreLoadSceneFromPrefab = nullptr;
        AnchorStoreClearRooms = nullptr;
        AnchorStoreClearRoom = nullptr;
        AnchorStoreOnOpenXrEvent = nullptr;
        AnchorStoreTick = nullptr;
        AnchorStoreRegisterEventListener = nullptr;
        AnchorStoreRaycastRoom = nullptr;
        AnchorStoreRaycastRoomAll = nullptr;
        AnchorStoreRaycastAnchor = nullptr;
        AnchorStoreRaycastAnchorAll = nullptr;
        AnchorStoreIsDiscoveryRunning = nullptr;
        AnchorStoreGetWorldLockOffset = nullptr;
        AddVectors = nullptr;
        TriangulatePolygon = nullptr;
        FreeMesh = nullptr;
        ComputeMeshSegmentation = nullptr;
        FreeMeshSegmentation = nullptr;
        _TestUuidMarshalling = nullptr;
        StringToMrukLabel = nullptr;
        CreateEnvironmentRaycaster = nullptr;
        DestroyEnvironmentRaycaster = nullptr;
        PerformEnvironmentRaycast = nullptr;
        SetTrackingSpacePoseGetter = nullptr;
        SetTrackingSpacePoseSetter = nullptr;
    }

    void* LoadFunction(const TCHAR* ProcName);

    static MRUKShared* Instance;
    void* MRUKSharedHandle;

    MRUKShared(void* handle);
    ~MRUKShared();
};
